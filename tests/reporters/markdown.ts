import type {
  FullConfig,
  FullResult,
  Reporter,
  Suite,
  TestCase,
  TestResult,
} from '@playwright/test/reporter';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Markdownãƒ¬ãƒãƒ¼ã‚¿ãƒ¼
 *
 * ãƒ†ã‚¹ãƒˆçµæœã‚’Markdownå½¢å¼ã§å‡ºåŠ›
 * GitHubã®PRã‚³ãƒ¡ãƒ³ãƒˆã‚„Slacké€šçŸ¥ã«ä½¿ç”¨å¯èƒ½
 */

interface TestInfo {
  test: TestCase;
  result: TestResult;
}

class MarkdownReporter implements Reporter {
  private startTime: Date;
  private tests: TestInfo[] = [];
  private config!: FullConfig;

  constructor() {
    this.startTime = new Date();
  }

  onBegin(config: FullConfig, _suite: Suite) {
    this.config = config;
  }

  onTestEnd(test: TestCase, result: TestResult) {
    this.tests.push({ test, result });
  }

  onEnd(result: FullResult) {
    const endTime = new Date();
    const duration = endTime.getTime() - this.startTime.getTime();

    const passed = this.tests.filter((t) => t.result.status === 'passed').length;
    const failed = this.tests.filter(
      (t) => t.result.status === 'failed' || t.result.status === 'timedOut'
    ).length;
    const skipped = this.tests.filter((t) => t.result.status === 'skipped').length;

    // Markdownç”Ÿæˆ
    let md = this.generateMarkdown({
      duration,
      passed,
      failed,
      skipped,
      total: this.tests.length,
      status: result.status,
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›
    const outputDir = 'test-results';
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const outputPath = path.join(outputDir, 'test-report.md');
    fs.writeFileSync(outputPath, md);

    console.log(`ğŸ“ Markdownãƒ¬ãƒãƒ¼ãƒˆ: ${outputPath}`);
  }

  private generateMarkdown(stats: {
    duration: number;
    passed: number;
    failed: number;
    skipped: number;
    total: number;
    status: FullResult['status'];
  }): string {
    const statusEmoji = stats.status === 'passed' ? 'âœ…' : 'âŒ';
    const statusText = stats.status === 'passed' ? 'æˆåŠŸ' : 'å¤±æ•—';

    let md = `# ${statusEmoji} ãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆ\n\n`;
    md += `**å®Ÿè¡Œæ—¥æ™‚**: ${this.startTime.toLocaleString('ja-JP')}\n\n`;

    // ã‚µãƒãƒªãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«
    md += `## ğŸ“Š ã‚µãƒãƒªãƒ¼\n\n`;
    md += `| é …ç›® | å€¤ |\n`;
    md += `|------|----|\n`;
    md += `| ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | ${statusEmoji} ${statusText} |\n`;
    md += `| å®Ÿè¡Œæ™‚é–“ | ${(stats.duration / 1000).toFixed(2)}ç§’ |\n`;
    md += `| ç·ãƒ†ã‚¹ãƒˆæ•° | ${stats.total} |\n`;
    md += `| âœ… æˆåŠŸ | ${stats.passed} |\n`;
    md += `| âŒ å¤±æ•— | ${stats.failed} |\n`;
    md += `| â­ï¸ ã‚¹ã‚­ãƒƒãƒ— | ${stats.skipped} |\n`;
    md += `| æˆåŠŸç‡ | ${((stats.passed / stats.total) * 100).toFixed(1)}% |\n\n`;

    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥çµæœ
    const byProject = this.groupByProject();
    if (Object.keys(byProject).length > 1) {
      md += `## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ¥\n\n`;
      md += `| ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ | æˆåŠŸ | å¤±æ•— | åˆè¨ˆ |\n`;
      md += `|------------|------|------|------|\n`;
      for (const [name, tests] of Object.entries(byProject)) {
        const p = tests.filter((t) => t.result.status === 'passed').length;
        const f = tests.filter(
          (t) => t.result.status === 'failed' || t.result.status === 'timedOut'
        ).length;
        const emoji = f > 0 ? 'âŒ' : 'âœ…';
        md += `| ${emoji} ${name} | ${p} | ${f} | ${tests.length} |\n`;
      }
      md += '\n';
    }

    // å¤±æ•—ã—ãŸãƒ†ã‚¹ãƒˆ
    const failures = this.tests.filter(
      (t) => t.result.status === 'failed' || t.result.status === 'timedOut'
    );
    if (failures.length > 0) {
      md += `## âŒ å¤±æ•—ã—ãŸãƒ†ã‚¹ãƒˆ\n\n`;
      for (const { test, result } of failures) {
        const projectName = test.parent.project()?.name || 'default';
        md += `### ${test.title}\n\n`;
        md += `- **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: ${projectName}\n`;
        md += `- **ãƒ•ã‚¡ã‚¤ãƒ«**: \`${path.basename(test.location.file)}:${test.location.line}\`\n`;
        md += `- **å®Ÿè¡Œæ™‚é–“**: ${(result.duration / 1000).toFixed(2)}ç§’\n\n`;
        if (result.error) {
          md += `**ã‚¨ãƒ©ãƒ¼**:\n\`\`\`\n${result.error.message?.slice(0, 500) || 'Unknown error'}\n\`\`\`\n\n`;
        }
      }
    }

    // é…ã„ãƒ†ã‚¹ãƒˆ
    const slowTests = this.tests
      .filter((t) => t.result.status === 'passed')
      .sort((a, b) => b.result.duration - a.result.duration)
      .slice(0, 5);

    if (slowTests.length > 0) {
      md += `## ğŸ¢ é…ã„ãƒ†ã‚¹ãƒˆ (Top 5)\n\n`;
      md += `| ãƒ†ã‚¹ãƒˆ | å®Ÿè¡Œæ™‚é–“ |\n`;
      md += `|--------|----------|\n`;
      for (const { test, result } of slowTests) {
        md += `| ${test.title} | ${(result.duration / 1000).toFixed(2)}ç§’ |\n`;
      }
      md += '\n';
    }

    // ãƒ•ãƒƒã‚¿ãƒ¼
    md += `---\n\n`;
    md += `*Generated by Playwright Custom Reporter*\n`;

    return md;
  }

  private groupByProject(): Record<string, TestInfo[]> {
    const result: Record<string, TestInfo[]> = {};
    for (const info of this.tests) {
      const name = info.test.parent.project()?.name || 'default';
      if (!result[name]) {
        result[name] = [];
      }
      result[name].push(info);
    }
    return result;
  }
}

export default MarkdownReporter;
